$PSDocId: Document Release 1.0 for Run-time Library Release 4.4$

TMDVIEW5	GsDOBJ5 型 オブジェクトを使ったTMDビューワー

                      Copyright(C) 1997 Sony Computer Entertainment Inc.
                                                    All Rights Reserved.


tuto0:	simpleなGsDOBJ５ビューワー
=====

<サンプルの解説>


	GsDOBJ5というオブジェクトは、プリセットパケットと呼ばれる
	タイプのデータを扱います。プリセットパケットとは、予め
	TMDで定義されているすべてのポリゴンのパケットをメモリー
	上に作成しておき必要な所だけを書き換えるとうものです。

	こうすることで、処理のネックになるメモリアクセスを軽減し
	高速化を計ります。例えば、光源計算をしないポリゴンについては、
	ポリゴンのRGB値は 書き換えません。

	プリセットパケットのもう一つの利点として、予めポリゴンの
	種類をまとめておき、ポリゴン毎に、種類のデコードを省ける
	という、ものがあります。

	オブジェクト毎にポリゴンの種類をまとめる TMDのフィルタを
	ちかじかリリースする予定です。

	これらの 技術により 従来のGsDOBJ2に比べて 倍近いスピード
	アップを達成しました。


	自動分割機能とは、アトリビュートに自動分割数を設定すると
	実行時にそのオブジェクトの表示されるポリゴンの全てを
	分割するものです。分割されたパケットは プリセットの領域とは
	別にとられるため、GsSetWorkBase()で設定する必要があります。



<起動方法>

	>psymake tuto0
	>psymake load
	>run tuto0

<コントローラの操作方法>

        ○ : オブジェクトの回転（右）
	△ : オブジェクトの回転（上）
	□ : オブジェクトの回転（左）
	× : オブジェクトの回転（下）
	方向キー : オブジェクトの平行移動
	R1 : オブジェクトの平行移動（手前）
	R2 : オブジェクトの平行移動（奥）
        SELECT : プログラム終了

＜備考＞

【モデリングデータ】

	モデリングデータは、以下の１６種類が用意されています。
	ファイル名の gは、 グーローシェーディングデータを
		     tは、 半透明データを
		     lは、 光源計算なしデータを表します。

	モデリングの形状は、すべて立方体でそのうち３面には
	テクスチャは張っておらず、残りの３面には、15bit,8bit,4bit
	のテクスチャが張ってあります。

	このプログラムは、モデリングデータを入れ換えるだけで
	ここにある１６種類すべてのデータをビューイングできます。

	cube3.tmd		フラット３角ポリゴン
	cube3g.tmd		グーロー３角ポリゴン
	cube3gl.tmd		グーロー光源計算なし３角ポリゴン
	cube3gt.tmd		グーロー半透明３角ポリゴン
	cube3gtl.tmd		グーロー半透明光源計算なし３角ポリゴン
	cube3l.tmd		フラット光源計算なし３角ポリゴン
	cube3t.tmd		フラット半透明３角ポリゴン
	cube3tl.tmd		フラット半透明光源計算なし３角ポリゴン

	cube4.tmd		フラット4角ポリゴン
	cube4g.tmd		グーロー4角ポリゴン
	cube4gl.tmd		グーロー光源計算なし4角ポリゴン
	cube4gt.tmd		グーロー半透明4角ポリゴン
	cube4gtl.tmd		グーロー半透明光源計算なし4角ポリゴン
	cube4l.tmd		フラット光源計算なし4角ポリゴン
	cube4t.tmd		フラット半透明4角ポリゴン
	cube4tl.tmd		フラット半透明光源計算なし4角ポリゴン

	また 一般的な モデリングデータ shuttle1.tmdも用意しました。


【テクスチャデータ】
	テクスチャデータは、6種類が用意されている。

	pat4.tim		4bitテクスチャデータ
	pat8.tim		8bitテクスチャデータ
	pat16.tim		16bitテクスチャデータ
	pat4t.tim		4bitテクスチャデータ(半透明）
	pat8t.tim		8bitテクスチャデータ（半透明）
	pat16t.tim		16bitテクスチャデータ（半透明）




tuto1:	GsDOBJ５を使った スプリット画面のサンプル
=====

＜サンプルの解説＞

	このプログラムは、画面を２分割して別々の視点から眺められる
	ようにしたものです。

	モデリングデータは、上下の画面とも共用で使っていますが、
	オブジェクトハンドラは、上下の画面で別々に用意しています。

	LIBGPUがキューイングするため、Draw命令は、連続的に
	送っても キューにつまれ すぐにリターンします。


<起動方法>

	>psymake tuto1
	>psymake load
	>run tuto1


<コントローラの操作方法>

	tuto0と同じ

<備考＞

【モデリングデータ】

	tuto0と同じ


tuto2:	GsDOBJ５を使ったオブジェクトの使い回し 及び 複数オーダリングテーブル
======

＜サンプルの解説＞

	このプログラムは、オブジェクトを使い回し、複数のOTに
	それぞれを割り当てた 複数OTのサンプルです。

	GsClearOt(offset,point,Wot2) で設定される Wot2のpointが
	GsSortOt(Wot2,Wot1)で参照され、Wot1のZテーブルに割り付け
	られます。

	サンプルでWot2のpointは、０でコールしていますので 必ず
	Wot2にソートされたオブジェクト２の方が、手前になります。
	コメントされているpointは、1<<OT_LENGTH-1です。これで
	コールすれば、オブジェクト２の方が必ず奥になります。


<起動方法>

	>psymake tuto2
	>psymake load
	>run tuto2

<コントローラの操作方法>

        ○ : オブジェクト０の回転（右）
	△ : オブジェクト０の回転（上）
	□ : オブジェクト０の回転（左）
	× : オブジェクト０の回転（下）
	方向キー : オブジェクト１の回転
	R1 : オブジェクト０の平行移動（手前）
	R2 : オブジェクト０の平行移動（奥）
	L1 : オブジェクト１の平行移動（手前）
	L2 : オブジェクト１の平行移動（奥）
        SELECT : プログラム終了


＜備考＞

【モデリングデータ】

	tuto0と同じ



tuto3:	GsDOBJ５を使った自動分割のサンプル
======

<サンプルプログラムの説明＞

	このプログラムは、オブジェクトの自動分割を行なったものです。

	自動分割の制御は、attributeにGsDIV1(2x2 4分割）、GsDIV2(4x4
	16分割）、GsDIV3(8x8 64分割)、GsDIV4(16x16 256分割）
	をor書きすることで設定します。

	分割用のパケットエリアは、プリセット領域とは別にとられるため
	GsSetWorkBase()で指定してやる必要があります。

<起動方法>

	>psymake tuto3
	>psymake load
	>run tuto3


＜備考＞
【モデリングデータ】

		tuto0と同じ


tuto4:	マルチスクリーン座標系
======

＜サンプルの説明＞

	このプログラムは SCREEN座標のスケーリングを変える関数
	GsScaleScreen()を用いたサンプルです。

	スクリーン座標系のスケーリングを変えることによって
	視点とオブジェクトの距離が16bitを超えても クリップする
	ことなく 表示できるようになります。

	例えば このサンプルでは スクリーン座標系を1/8にスケーリング
	しているため オブジェクトと視点がの距離が１６ビットを超えても
	１９ビット以内であれば 表示可能です。

	注意事項として スクリーン座標系をスケーリングすると 
	OTのスケールも変化します。スケールの違うスクリーン座標系
	で計算したオブジェクトは 同じスケールでOTに登録しては
	いけません。

	例えば 1/8スケールのスクリーン座標系で計算したオブジェクト
	を ソートしたOTに ノーマルスケーリングのスクリーン座標で
	計算したオブジェクトをソートするには SortObjectのshift値を
	３余計に増やす必要があります。



＜コントローラの操作方法＞

        ○ : オブジェクトの回転（右）
	△ : オブジェクトの回転（上）
	□ : オブジェクトの回転（左）
	× : オブジェクトの回転（下）
	方向キー : オブジェクトの平行移動
	R1 : オブジェクトの平行移動（手前）
	R2 : オブジェクトの平行移動（奥）
	L1 : screen座標 1/8 SCALING
	L2 : screen座標 NORMAL SCALING
        SELECT : プログラム終了


<起動方法>

	>psymake tuto4
	>psymake load
	>run tuto4


＜備考＞

【モデリングデータ】

		tuto0と同じ


＜備考＞

【モデリングデータ】

		tuto0と同じ


tuto5:	tuto0.cをGsSortObject5J()を使って書き換えたサンプル
======

＜サンプルの説明＞

	このプログラムは GsSortObject5()をGsSortObject5J()に
	書き換えたものです。GsSortObject5J()を使うことで
	GsSortObject5()で呼んでいる 下位関数のうち 不要なものを
	リンクせず コードを小さくすることができます。

	変更した部分は init_all()中で jt_init()を呼ぶようにしたことと
	GsSortObject5 -> GsSortObject5J に変えた部分だけです。

	jt_init()の中では GsPrstF3L,GsPrstTF3Lのみを登録しているので
	光源計算型のフラット３角形 でかつ 標準の光源計算をする機能
	しかありません。よって 自動分割、FOG計算、光源計算OFFを
	設定することはできません。

	ただし 機能を絞っていることで コードサイズは tuto0に比べて
	48Kbyteも減少しています。

	もし より多くの機能を使う場合は それに応じた関数をテーブルに
	登録すればいいのです。全ての関数をテーブルに登録すると
	GsSortObject5()とコンパチになります。
	GsSortObject5()とコンパチになる jt_init()のひな型が
	libgs.hにコメントとして入っています。jt_init5()
	GsSortObject5() どの下位関数が使われているかを 調べるには
	取り敢えず dmyを先頭につけた関数を登録してみてください。
	（dmyGsPrstF3L,dmyGsPrstTF3Lなど）
	この関数は 最初に呼ばれた時に その関数の タイプをprintf
	します。


<起動方法>

	>psymake tuto5
	>psymake load5
	>run tuto5


＜備考＞

【モデリングデータ】

	cube3.tmdに限定	



tuto6:	tuto0.cをモデルを動かすのではなく 視点を主観的に動かしたサンプル
======

＜サンプルの説明＞

	このプログラムは 視点を主観的に動かすサンプルです。
	キーにアサインされている 動きは全て視点座標系に従います。
	例えばZ軸の平行移動をすると 視線の方向に進みます。
	回転移動は 視線の方向を変化させます。

	プログラムは 座標系を一つ用意し（DView) その座標系にカメラを
	ぶら下げています。DViewを 主観的に動かしたいため 平行移動
	は DView内での移動に Dview.coordを掛けてWorld座標系の
	移動に変換して指定しています。

	回転移動に関しては tuto0の様に 回転角から 毎フレーム回転
	マトリックスを求めると 主観的移動では計算が複雑化するため
	直前のフレームのマトリックスを使って計算しています。

	しかし この計算法では誤差が蓄積されてしまうので 形が
	歪んできてしまいます。それを避けるために MatrixNormal()
	をコールしています。MatrixNormal()は 形を歪めるマトリックス
	を 歪めないマトリックスへ正規化します。

	ただし 平行移動に関しては このプログラムでは正規化していない
	ので 誤差が蓄積されてしまいます。その弊害として 例えば
	中心を回る軌道が 長時間回り続けると 中央に縮退するなどの
	弊害があるので注意が 必要です。

<起動方法>
	>psymake tuto6
	>psymake load
	>run tuto6

<コントローラの操作方法>

        ○ : 視点の回転（右）
	△ : 視点の回転（上）
	□ : 視点の回転（左）
	× : 視点の回転（下）
	方向キー : 視点の平行移動
	R1 : 視点のZ軸の平行移動(手前）
	R2 : 視点のZ軸の平行移動(奥）
	L1 : 視点のZ軸回りの回転(時計回り）
	L2 : 視点のZ軸回りの回転（半時計回り）
        SELECT : プログラム終了


＜備考＞

【モデリングデータ】

		tuto0と同じ

								以上
